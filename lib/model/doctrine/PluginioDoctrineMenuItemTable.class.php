<?php

/**
 * PluginioDoctrineMenuItemTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class PluginioDoctrineMenuItemTable extends Doctrine_Table
{

  /**
   * Creates a full ioMenuItem tree from the given $name, which is either:
   *   * The name of a root menu node
   *   * An ioMenuItem object that the menu will be sourced from
   *
   * @param  string|ioDoctrineMenuItem $name The root node to translate into an ioMenuItem
   * @return ioMenuItem
   */
  public function fetchMenu($name)
  {
    if (is_string($name))
    {
      $name = $this->fetchRootByName($name);
    }

    if (!$name)
    {
      return null;
    }

    return $name->createMenu();
  }

  /**
   * Persists an ioMenuItem tree to the database.
   *
   * Typically, you'll persist your entire menu tree. This will save the root
   * menu item as a root in Doctrine's nested set with the whole tree under it:
   *
   * $menu = new ioMenuItem('root');
   * $menu->addChild('Home', '@homepage');
   * Doctrine_Core::getTable('ioDoctrineMenuItem')->persist($menu);
   *
   * You can also persist part of a tree or persist a full menu under an
   * existing Doctrine nested set node:
   *
   * $menu->addChild('Links');
   * $menu['Links']->addChild('Sympal', 'http://www.sympalphp.org');
   * $tbl = Doctrine_Core::getTable('ioDoctrineMenuItem');
   * $node = $tbl->findOneByName('some name'); // find an existing node
   * // save the Links submenu under the above node
   * $tbl->persist($menu['Links'], $node);
   *
   * @param  ioMenuItem $menu
   * @param  ioDoctrineMenuItem $parentDoctrineMenu Optional parent node, else
   *                                                it will save as root
   * @return ioDoctrineMenuItem
   * @throws sfException
   */
  public function persist(ioMenuItem $menu, ioDoctrineMenuItem $parent = null)
  {
    // run a few sanity checks and create the root node
    if (!$parent)
    {
      // protect against people calling persist on non-root objects, which
      // would otherwise cause those items to persist as new roots
      if (!$menu->isRoot())
      {
        throw new sfException(
          'Non-root menu items as root items. Either persist the entire
          tree or pass an ioDoctrineMenuItem parent as the second argument.'
        );
      }

      // Make sure the root has a name
      if (!$menu->getName())
      {
        throw new sfException(
          'A root object cannot be persisted without a name. Call setName()
          on the root menu item to set its name'
        );
      }

      $root = $this->fetchRootByName($menu->getName());
      if (!$root)
      {
        // create a new root
        $class = $this->getClassnameToReturn(); // allow for inheritance
        $root = new $class();
        $root->name = $menu->getName();
        $root->save();
        $this->getTree()->createRoot($root);
      }

      $parent = $root;
    }

    // merge in the menu data into the parent menu
    $parent->persistFromMenuArray($menu->toArray());

    return $parent;
  }

  /**
   * Retrieves the root menu item specified by the given name
   *
   * @param  $name The value of the name field of the menu item
   * @return ioDoctrineMenuItem|null
   */
  public function fetchRootByName($name)
  {
    return $this->createQuery('m')
      ->select('m.*')
      ->leftJoin('m.Permissions p')
      ->addSelect('p.id, p.name')
      ->where('m.lft = ?', 1)
      ->andWhere('m.name = ?', $name)
      ->fetchOne();
  }
  
  /**
   * Clear a tree based on a root id.  Leave the root node intact
   *
   * @param string $name - the name id to match the branch on
   * @return void
   * @author Brent Shaffer
   */
  public function clearTree(ioDoctrineMenuItem $root)
  {
    $nodes = $this->createQuery()
      ->where('root_id = ?', $root['id'])
      ->andWhere('level != ?', 0)
      ->execute();

    foreach ($nodes as $node)
    {
      $node->getNode()->detach();
      $node['level'] = null;
      $node->save();
    }
  }

  /**
   * builds a tree from a nested array.
   *
   * @param string $arr 
   * @param string $orgId 
   * @return void
   * @author Brent Shaffer
   */
  public function restoreTreeFromNestedArray($arr, ioDoctrineMenuItem $root)
  {
    if (!$root->getNode()->isRoot())
    {
      throw new sfException('ioDoctrineMenuItemTable::restoreTreeFromNestedArray() must be called using a root node.');
    }

    // put the nodes back on
    $this->restoreBranchFromNestedArray(array('menu' => $root, 'children' => $arr));
  }

  /**
   * recursive function to create a nested set sourced from an array
   *
   * @param array $arr The source array with keys menu and children
   * @return ioDoctrineMenuItem
   * @author Brent Shaffer
   */
  public function restoreBranchFromNestedArray($arr)
  {
    $parent = $arr['menu'];

    if (isset($arr['children']))
    {
      // for details on why we do this, see ioDoctrineMenuItem::persistFromMenuArray()
      $children = array_reverse($arr['children']);
      foreach ($children as $childArr)
      {
        $child = $this->find($childArr['id']);
        $child->getNode()->moveAsFirstChildOf($parent);

        // put the child object into the array
        $childArr['menu'] = $child;
        unset($childArr['id']);

        // recurse down and ultimately refresh the parent
        $this->restoreBranchFromNestedArray($childArr);
      }
    }

    return $parent;
  }

  /**
   * Whether or not this class implements I18n
   *
   * @return boolean
   */
  public function isI18n()
  {
    return $this->hasTemplate('Doctrine_Template_I18n');
  }

  /**
   * Used by the admin module, this attempts to retrieve the menu items
   * in an order so that the different trees are segregated and each
   * tree is drawn out in its natural tree order.
   *
   * @return Doctrine_Query
   */
  public function getOrderedTreeQuery()
  {
    return $this->createQuery('m')
      ->orderBy('m.root_id ASC')
      ->addOrderBy('m.lft ASC');
  }

  /**
   * Used in the admin for building the drop-down of potential "parents"
   * for a given menu item.
   *
   * @return Doctrine_Query
   */
  public function getParentIdQuery()
  {
    return $this->createQuery('m');
  }
}